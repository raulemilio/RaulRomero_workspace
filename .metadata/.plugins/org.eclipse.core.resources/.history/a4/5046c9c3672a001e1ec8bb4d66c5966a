#include "API_debounce.h"


typedef enum{
	   BUTTON_UP,
	   BUTTON_FALLING,
	   BUTTON_DOWN,
	   BUTTON_RAISING,
  } debounceState_t;

  static debounceState_t debounce_state;

  bool_t buttonPress;

  static bool_t global=false;

  delay_t * debounceDelay;
  delay_t * debounceDelayBlinkyLed;

  tick_t DEBOUNCE_TIME;
  tick_t BLINKY_TIME_1=100;

  bool_t readKey(void);

void debounceFSM_init(void)
{
	  // Inicialización de la variable de estado
	  debounce_state=BUTTON_UP;
	  //GPIO_INPUT
	  BSP_PB_Init(BUTTON_USER, BUTTON_MODE_GPIO);
	  //GPIO_OUPTUP
	  BSP_LED_Init(LED1); // Utilizado en estado FALLING. Función buttonPressed()
	  BSP_LED_Init(LED2); // Utilizado en estado RAISING. Función buttonReleased()
	  BSP_LED_Init(LED3); // Utilizado en estado de ERROR
	  // inicialización del tiempo de delay para el retardo
	  delayInit(&debounceDelay,DEBOUNCE_TIME);
	  delayInit(&debounceDelayBlinkyLed,BLINKY_TIME_1);
}

void debounceFSM_update(void)
{
	/*
	  buttonPress= readKey();
	  if(delayRead(&debounceDelayBlinkyLed)==true)
	  {
			BSP_LED_Toggle(LED2);
	  }
	  */
	  switch (debounce_state) {
	  		case BUTTON_UP:
	  			// Chequear condiciones de transición de estado
	  			if(BSP_PB_GetState(BUTTON_USER)==1){
	  				// Cambio a próximo estado
	  				debounce_state = BUTTON_FALLING;
	  			}else
	  			{
	  				// Vuelvo a estado anterior
	  				debounce_state = BUTTON_UP;
	  			}
	  		break;

	  		case BUTTON_FALLING:
	  			// Se verifica que haya pasado el tiempo de delay para el antirebote y
	  			// además que el el botón esté pulsado
	  			if((delayRead(&debounceDelay)==true)&(BSP_PB_GetState(BUTTON_USER)==1))
	  			{
	  				global=true;
	  				BSP_LED_Toggle(LED1);
	  				debounce_state = BUTTON_DOWN;

	  			}else
	  			{
	  				debounce_state = BUTTON_UP;
	  			}
	  		break;

	  		case BUTTON_DOWN:
	  			  // Cambio de estado
	  			  if(BSP_PB_GetState(BUTTON_USER)==0){
	  				  debounce_state = BUTTON_RAISING;
	  			  }

	  		break;

	  		case BUTTON_RAISING:
	  			// Se verifica que haya pasado el tiempo de delay para el antirebote y
	  			// además que el el botón esté soltado
	  			if((delayRead(&debounceDelay)==true)&(BSP_PB_GetState(BUTTON_USER)==0))
	  			{
	  				BSP_LED_Toggle(LED2);
	  				debounce_state = BUTTON_UP;

	  			}else
	  			{
	  				debounce_state = BUTTON_DOWN;
	  			}

	  		break;

	  		default:
	  			// si no se reconoce un estado conocido se reinicia la máquina
	  			debounceFSM_init();
	  			// se enciende el LED3 y se queda en estado de error permamente
	  			//Error_Handler();
	  		break;
	    }
}

bool_t readKey( void )
{
	bool_t ret;
	global=true;

	if(debounce_state == BUTTON_DOWN){
		ret=false;
	}
	return ret;
}


