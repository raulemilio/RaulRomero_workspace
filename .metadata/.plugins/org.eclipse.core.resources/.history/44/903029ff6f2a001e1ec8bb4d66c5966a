#include "API_debounce.h"

#define DEBOUNCE_TIME=40

// Variables internas

  typedef enum{
	   BUTTON_UP,
	   BUTTON_FALLING,
	   BUTTON_DOWN,
	   BUTTON_RAISING,
	} debounceState_t;

  static debounceState_t debounce_state; // estado de la FSM  privada estatica

  // variable interna que cambia cuando se presiona el botón
  bool_t buttonPress; // variable interna pedida en el trabajo práctico
  // Variable interna auxiliar para hacer el toggle entre los dos tiempos 100ms y 500 ms
  bool_t toggleBlinkyTimeLed;

  // variable interna pedida en el trabajo práctico que se actualiza cuando se
  // hace un llamado a la función readKey() y se está en el estado BUTTON_FALLING
  static bool_t global=false;

  // delay para la FSM
  delay_t debounceDelay;
  // delay para el tiempo de toggle del LED2
  delay_t debounceDelayBlinkyLed;

  // tiempo para FSM (antirebote)
 // tick_t DEBOUNCE_TIME=40;
  // tiempos de toggle del LED2
  tick_t BLINKY_TIME_1=100;
  tick_t BLINKY_TIME_2=500;

  bool_t readKey(void);

void debounceFSM_init(void)
{
	  // Inicialización de la variable de estado
	  debounce_state=BUTTON_UP;
	  //GPIO_INPUT
	  BSP_PB_Init(BUTTON_USER, BUTTON_MODE_GPIO);
	  //GPIO_OUPTUP
	  BSP_LED_Init(LED1); // Utilizado en estado FALLING. Función buttonPressed()
	  BSP_LED_Init(LED2); // Utilizado en estado RAISING. Función buttonReleased()
	  BSP_LED_Init(LED3); // Utilizado en estado de ERROR
	  // inicialización del tiempo de delay para el retardo
	  delayInit(&debounceDelay,DEBOUNCE_TIME);
	  delayInit(&debounceDelayBlinkyLed,BLINKY_TIME_1);
}

void debounceFSM_update(void)
{
	  buttonPress=readKey();

	  if(buttonPress==false){
		  if(toggleBlinkyTimeLed==true)
		  {
			  delayWrite(&debounceDelayBlinkyLed,BLINKY_TIME_1);
		  }else
		  {
			  delayWrite(&debounceDelayBlinkyLed,BLINKY_TIME_2);
		  }
		  toggleBlinkyTimeLed=!toggleBlinkyTimeLed;
	  }
	  if(delayRead(&debounceDelayBlinkyLed)==true)
	  {
			BSP_LED_Toggle(LED2);
	  }

	  switch (debounce_state) {
	  		case BUTTON_UP:
	  			// Chequear condiciones de transición de estado
	  			if(BSP_PB_GetState(BUTTON_USER)==1){
	  				// Cambio a próximo estado
	  				debounce_state = BUTTON_FALLING;
	  			}else
	  			{
	  				// Vuelvo a estado anterior
	  				debounce_state = BUTTON_UP;
	  			}
	  		break;

	  		case BUTTON_FALLING:
	  			// Se verifica que haya pasado el tiempo de delay para el antirebote y
	  			// además que el el botón esté pulsado
	  			if((delayRead(&debounceDelay)==true)&(BSP_PB_GetState(BUTTON_USER)==1))
	  			{
	  				global=true;
	  				BSP_LED_Toggle(LED1);
	  				debounce_state = BUTTON_DOWN;

	  			}else
	  			{
	  				debounce_state = BUTTON_UP;
	  			}
	  		break;

	  		case BUTTON_DOWN:
	  			  // Cambio de estado
	  			  if(BSP_PB_GetState(BUTTON_USER)==0){
	  				  debounce_state = BUTTON_RAISING;
	  			  }

	  		break;

	  		case BUTTON_RAISING:
	  			// Se verifica que haya pasado el tiempo de delay para el antirebote y
	  			// además que el el botón esté soltado
	  			if((delayRead(&debounceDelay)==true)&(BSP_PB_GetState(BUTTON_USER)==0))
	  			{
	  				BSP_LED_Toggle(LED3);
	  				debounce_state = BUTTON_UP;

	  			}else
	  			{
	  				debounce_state = BUTTON_DOWN;
	  			}

	  		break;

	  		default:
	  			// si no se reconoce un estado conocido se reinicia la máquina
	  			debounceFSM_init();
	  			// se enciende el LED3 y se queda en estado de error permamente
	  			//Error_Handler();
	  		break;
	    }
}

bool_t readKey( void )
{
	bool_t ret;
	global=true;

	if(debounce_state == BUTTON_DOWN){
		ret=false;
	}else
	{
		ret=true;
	}
	return ret;
}


